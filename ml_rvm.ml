let input = "R\'rdadac,>,=>,qssa,oludom,htgnel-rotcev,?=<rahc,?qe,rahc-etirw,?regetni,?orez,etacnurt,xam,?=gnirts,!llif-rotcev,!tes-gnirts,gnirtsbus,regetni>-rahc,htgnel-gnirts,gniliec,tel,fer-rotcev,?=>gnirts,raaaac,?=>rahc,rddaac,dna,?=rahc,!tes,=,raddac,?<rahc,rotaremun,mcl,rotcev-ekam,enifed,!llif-gnirts,rahc>-regetni,?>rahc,qmem,rdaaac,adbmal,?naeloob,raaddc,?=<gnirts,?evitisop,gnirts-ekam,radaac,rotanimoned,!rdc-tes,raaadc,raadac,rddadc,ro,rorre,fi,nim,roolf,?evitagen,etouq,!tes-rotcev,cc/llac,ypoc-gnirts,dnuor,radddc,nigeb,radadc,=<,dnoc,rdaddc,rdaadc,rddddc,dneppa-gnirts,?ddo,tixe,?<gnirts,pam,vmem,?>gnirts,?erudecorp,tsil>-rotcev,tpxe,gnirts>-rebmun,esrever,?rotcev,!rac-tes,fer-gnirts,redniamer,cossa,rebmun>-gnirts,lave,rebmem,vssa,?neve,hcae-rof,dcg,lobmys>-gnirts,gnirts>-lobmys,raac,radc,raadc,raaac,rdddac,lper,?gnirts,rdadc,rdaac,fer-tsil,radac,raddc,rdddc,?tcejbo-foe,enilwen,rotcev>-tsil,dneppa,+,sba,?lobmys,?llun,yalpsid,etirw,htgnel,daer,rahc-keep,?lauqe,rddac,tneitouq,,gnirts>-tsil,tsil>-gnirts,ton,,,rddc,,,*,,rdac,,,,rac,?riap,rahc-daer,<,-,rdc,snoc,,?vqe,,,,,;9)!S,9Fl@YN@YF_@YGiU7@YG^{])9)@YN@YFZ6^8N~YO^YD@YT8vCvR3y]67#YU.^z!U.8THi&:HiU6ai&kkz!U6:kw\'k!TJ\'_*YTJaB_G^~F^{!T9\'^8T9YKlbB`^\'`~?_G_~F_|!TA8TG`^YT9ka_BaG`1YTAdBbAai$G`^~F_|!U/#`kn8:^~i$#`kn8:^~i$#`kn8:^~i$#`kn8:^~YT5Q^~?w)I^~?kJ^~YT5^z!U\'#YU/a_l{!TG#a_k#k_k~?iU6_{!?1b1:VfBdbw)k~FBaG`^|!T<1V:h-w7k1Vf~?iU6fdAaaa^}(!TF*i&^z!TI*YTF`^{!TB*YTIb`^|!T7*YTBca_wS+|!1#b`n8T<fAi&AbwU4awU4`8TAAea_`~YI_B`1ci$1cYT7APdxLABKcxOGKa1cABKbxO~?GKbwU5~FBa_~?xL^1ci$1cN^1cNYTBYT7APgwS-wU4wU4YTFYTI`wU4wSN~FPbKa~FBa_~?wS-^1ci%1cN^1cNYT7i$APdwSH^~FPbKa~FBa_~?wSH^8T<fPdK`G_`GK`~?wSN^8?cBa_~?xO^#YTGewT?#d~YHbYTHi&:ViU6PeYTJAAfi$i$akYE_nK`~?wS9^1:HgZ*ecHfYAdboKa_~?wS+^1YU\'dYT9lbKbYAa_~N?wS?_8T<fAi&AbwU4awU4`8TAAea_`~YI_B`1ci$1cYT7APdxLABKcxOGKa1cABKbxO~?GKbwU5~FBa_~?xL^1ci$1cN^1cNYTBYT7APgwS-wU4wU4YTFYTI`wU4wSN~FPbKa~FBa_~?wS-^1ci%1cN^1cNYT7i$APdwSH^~FPbKa~FBa_~?wSH^8T<fPdK`G_`GK`~?wSN^8?cBa_~?xO^#YTGewT?#d~YHbYTHi&:ViU6PeYTJAAfi$i$akYE_nK`~?wS9^1:HgZ*ecHfYAdboKa_~?wS+^1YU\'dYT9lbKbYAa_~N^~^?wSF^#cKan~?wS\'^G_~F_#bYT9k``m~YI_|!T85_@L^{!N5uy!T,i5!;\'i$8;aB_@L^8;aB_@L^@LvS#~N?vS#_8;aB_@L^8;aB_@L^@LvS#~N^~^?vE^8;aB_@LvS;@LvS#~?t^8;aB_@LvS9@LvS#~?v0^8;aB_@LvS5@LvS#~?u^8;aB_@L^~S`G^~F^{!TL\'i$\'i$8TLB^@YFG^~F^@LvC~F^z!G8GZ>^8T8vS7vF~ZA^8FZ@^@LvF~Z<^8;i$T^~Z(^8GZ/^~YI^5vL@YTLB^@YFG^@LvK~F^8T8vLvK~YH^8T8vS;vF~?i%^8T8vS-vF~S^z!F8G^5vE@Ri%T^@LvE~Z(^z!TN8TN8T>~?u^\'^~Dk^Ey!T>8T>@E\'^8TN~?vR0^~D_vC\'iU8~YO^YCy!T68T6A`^8T6Aa^8T6Aat~?vS;^8T6Aav0~?vS9^8T6Aau~?vS5^E~?vS#^9=_~?vE^\'i&~YO^Ez!T=*YT=^@E\'i&~NNDvD`*YT=^@E\'i&~NN^~^?vL_*YT=^@E\'i&~N^~^?vK^YCy!TM*YTM^YD\'i&@E~?vL^YT>y!8\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~DvR<^~D_vR588CCvR%_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~DvR<^~D_vR588CCvR%_M`v3@E~DvR/^~D_vR$YCz!D90`\'^~^^Z7^UAYT=^@E8>YT6i&@E~?vE^*Ai&YDwS\'@E~?vJ^8MYD,Okk88k@E~?vP^YC@E~N?vRM_8MYD,Okk88k@E~?vP^YC@E~N^~^?vS?^\'i%@E~?vS;^\'i$@E~?vS-^YC@E~?vF^8TM@E~?vK^\'^~Dk^YT>y!C\'^!U1^Ey!U&\'^!U1iU3\'^~?iU8^!U1^z!.8U&^8U&YU+~?iU3^\'^~?iU8^iU1y!U1iU3!O(iU8^z!S%7%YT?\'_@YU0Qc^@YTDJc^IIYT?i$zIIYT?i$z]2\'i$92B`^@X$G_~F_{]D\'i&*ZDBa_X$G_~F_{!TH#l`^{]AYT:l!T&8TDYT;aI_^{!S@8MYT;k^z!S&8TOb`J^|!SM9%`J^{!T/i2]@i3!M#oYE_^z]<YT:o!S>8TDYT;aI_^{!S$8>YLi&T^z]H8>YLT`T^{!TP8>a8TPAfZ:bb`a_Cl`~Da_}\'!T$8TPi&b`^|!U*\'k\'iU8~F_\'l8U*BbB`\'l~D`^\'iU8~D__G`G^~F_~F^{!TK8U*T`T^{!SL8<ZE`^{!S68<ZB`^{]B-YTKa_k{]E-kYTK`^{!T\'(kYTK`^{!S48>YT;vC^z!T%8TOb`J^|]:9%`J^{!SPi2!=i3!>#nYE_^z](YT:n!S=i\'!T#i\'!SJiT2!T.jM!S<iT3!SCi-!SGi(!U#\'_\'i$\'i$8U#CCvR%`MbuB_~DvR/^~D_vR$G^~F^{!U)8U#k^\'i$~YH^z]7\'i$,_k~^YU)^8U)B^~?vPG^\'i$~YH^T^z!TC\'^8TC_`~DakAb^YKCMu``vR%Wu^{]>8>YTCi&^8>AYTCi&C`kvP~Dk^z]?\'^6__~ZG`Z?Wm`M_^\'l~?k_{!S#i\'!T)i\'!SOi\'!S)i\'!S2\'lz!SBi\'!SA6_WZ1``_YJ`YJ^\'k~?k_{!T@8T@_Z9__\'_~?k^{]18T@`^8T@__~D__YJ`YJ^{!T08Kb^\'^~?DkbDk`\'k~?k^CM`a_W`^{]9,MWb``^{!J\'^,_k~Dk^z!S*\'_\'^~D`^{!T(\'^\'_~D`^{]G8<Z3^z]3(MWm`m^z!S(-k^z!S5-_kz!T*(k^z!T28<D`^{]M8<D__{!T3-__{!SEi(!T+8<YT5^z@YU,ki#!U2Ii#!U$\'^!U2AiU2^YU-^8U$Ia_\'^~YB`I^J_~F_{]08U$iU2^z]/i2!U-#m_i$z!IYT:m!U(\'`8U(Aca`Cl^~D_k|!T;8U(i&`^{]8\'i$98Ba_\'^~YBG__G_~F_{!T1j4]4\'i$94Ba_\'^~?G__G_~F_{]5\'i$95B`^\'_~YBG`^~F_{!S;jC]C\'i$9CB`^\'_~?G`^~F_{!TE\'^8TECl`B^~D`k{!TO9;aYTE`^|]%0YTE`^{!U%\'_8U%AaG_B^~F^{]=8U%i&^z!L\'_*YLaB_G^~F^{!E\'k8KYEB_l~F^z!H(i&^z]I8PI^z]P8PJ^z]K9#I^z!S79#J^z!S.9\'I^z]N9\'J^z]J9,I^z!S09,J^z!SD8AJ^z!T49$I^z!S/9$J^z!SI9&I^z!S39&J^z!S:9+I^z!SK9+J^z!P89I^z]#89J^z]\'9-I^z],9-J^z]$4J^z]&9.I^z]+9.J^z]-2J^z].3J^z]*8AI^z!A4I^z!92I^z!43I^z!S1iU,];iTD!+i2!0i3!*#k`^{!/YT:k!B\'i$\'i$\'i$\'i$8BJaJ_~YBIaI_~YBQaQ_~YT5`\'i$~?pQ_~YT5_\'^~^?`^{!T-i(!S88<_\'^~^?i%^z!<(i$^z!T:8T?\'i$(bQ^~YT5^zz!U7:nl:ki&vC!U3Cmk!U8Clk!\':lkl!):lkm!7:lkn!T?:lko!T5:lkp!3:lkq!2:lkr!::lks!TD:lkt!U,:lku!U0:lkv.!(:lkv/!-:lkv0!K:lkv1!,:lkv2!6:lkv3!@:lkv4!U+:lkv5!5:lkv6]F:lkv7y"
let debug = ref false

let free_list = ref [450000]
let _ =
  let rec loop n =
      if n < 900000
      then begin
      free_list := n :: !free_list;
      loop (n+1)
      end
  in loop 450000

let print_debug s = if !debug then print_endline s

type word =
  Triplet of int
  | Int of int
  | Nil

type rib = word * word * word

let pair_type = Int 0
let procedure_type = Int 1
let symbol_type = Int 2
let string_type = Int 3
let vector_type = Int 4
let singleton_type = Int 5

let _nil = (Int 0, Int 0, singleton_type)
let _false = (Int 0, Int 0, singleton_type)
let _true = (Int 0, Int 0, singleton_type)

let size_ram = 900000
let ram = Array.make size_ram _nil
let stack = ref size_ram
let heap = ref 10000
let pc = ref 0
let np = ref (-1)
let pos = ref 0

let rec show_rib (car, cdr, ty) =
  print_string "(";
  show_word car;
  print_string ", ";
  show_word cdr;
  print_string ", ";
  show_word ty;
  print_string ")"

and show_word = function
  Triplet i ->
    show_rib ram.(i)
  | Int i -> print_int i
  | Nil -> print_string "nil"
  
(* init constants *)
let nil_rib = Triplet 0
let true_rib = Triplet 2
let false_rib = Triplet 3

let int_of_triplet (w : word) : int =
  match w with
  Triplet i -> i
  | Int _ | Nil -> failwith "can't int_of_triplet"

let int_of_Int (w : word) : int =
  match w with
  Int i -> i
  | Triplet _ | Nil -> failwith "can't int_of_Int"

let get_rib (w : word) =
  match w with
  Triplet i -> ram.(i)
  | Int _ | Nil -> failwith "can't get_rib"

let is_rib (w : word) : bool =
  match w with
  Triplet i -> i >= 0 && i < size_ram
  | Int _ | Nil -> false

let is_eqv (w1 : word) (w2 : word) : bool =
  match w1, w2 with
  Int i, Int j -> i = j
  | Triplet i, Triplet j -> (get_rib w1) = (get_rib w2)
  | _ -> false

let is_false (w : word) = match w with
  Int i -> false
  | Triplet i -> i = 3
  | Nil -> false

let make_rib x y z = (x, y, z)

let field0_rib (x, y, z) = x
let field1_rib (x, y, z) = y
let field2_rib (x, y, z) = z

let field0_word (w : word) = get_rib w |> field0_rib
let field1_word (w : word) = get_rib w |> field1_rib
let field2_word (w : word) = get_rib w |> field2_rib

let field0_set (w : word) (v : word) =
  match w with
  Triplet i ->
    ram.(i) <- (v, field1_word w, field2_word w)
  | Int _ | Nil -> failwith "can't field0_set"

let field1_set (w : word) (v : word) =
  match w with
  Triplet i ->
    ram.(i) <- (field0_word w, v, field2_word w)
  | Int _ | Nil -> failwith "can't field0_set"

let field2_set (w : word) (v : word) =
  match w with
  Triplet i ->
    ram.(i) <- (field0_word w, field1_word w, v)
  | Int _ | Nil -> failwith "can't field0_set"

let instance_of ty =
  fun (w  : word) -> is_rib w && field2_word w = ty

let is_pair (w : word) = instance_of pair_type w
let cons car cdr = make_rib car cdr pair_type
let get_car (w : word) = field0_word w
let get_cdr (w : word) = field1_word w

let pop () : word =
  let (car, cdr, _) = ram.(!stack) in
  stack := int_of_triplet cdr;
  (*print_string "POP ";
  show_word car;
  print_newline ();*)
  car

let push (w : word) : unit =
  let get_next_i () =
    (* should be responsible for
       triggering garbage collection *)
    stack := List.hd !free_list;
    free_list := List.tl !free_list;
  in
  let new_tos = cons w (Triplet !stack) in
  get_next_i ();
  ram.(!stack) <- new_tos

let alloc_rib (r : rib) : word =
  let get_next_i () =
    (* should trigger GC aswell *)
    heap := !heap + 1
  in
  get_next_i ();
  ram.(!heap) <- r;
  Triplet !heap

let tos () = Triplet !stack

let rec list_tail (w : word) (i : int) : word =
  if 0 < i
  then list_tail (get_cdr w) (i-1)
  else w

let rec pair_length (w : word) =
  if is_pair w
  then 1 + pair_length (get_cdr w)
  else 0

let get_byte () =
  let c = String.get input (!pos) in
  pos := !pos + 1;
  int_of_char c

let eb = 46

let get_code () =
  let x = (get_byte ()) - 35 in
  if x < 0 then 57 else x

let rec get_int n =
  let x = get_code () in
  let y = n * eb in
  if x < eb
  then y + x
  else get_int (y + (x - eb))


(* symbol table *)
let symtbl = ref 4
let top_symbtl () =
    Triplet !symtbl

(* length from w till Nil *)
let rec length (w : word) : int =
  if is_pair w
  then 1 + (length (get_cdr w))
  else 0

let string_of_list (w : word) : rib =
  make_rib w (Int (length w)) string_type

let end_of_string (w : word) : rib =
  make_rib false_rib w symbol_type

let alloc_sym (sym : rib) =
  let get_next_i () =
    (* should trigger GC aswell *)
    symtbl := !symtbl + 1
  in
  get_next_i ();
  ram.(!symtbl) <- sym;
  Triplet !symtbl

let add_symbol (chars : word) =
  let top = top_symbtl () in
  let str_rib = string_of_list chars |> alloc_sym in
  let end_rib = end_of_string str_rib |> alloc_sym in
  let sym = cons end_rib top in
  alloc_sym sym

let build_symbtl () =
  let rec loop1 n =
    if 0 < n
    then begin
      let _ = add_symbol nil_rib in
      loop1 (n-1)
    end
    else loop2 ()
  and loop2 () =
    loop3 nil_rib
  and loop3 chars =
    let x = get_byte () in
    if x = 44
    then let _ = add_symbol chars in loop2 ()
    else if x = 59
    then let _ = add_symbol chars in ()
    else begin
      let c = cons (Int x) chars in
      let c_rib = alloc_rib c in
      loop3 c_rib
    end
  in loop1 (get_int 0)

let decode () =
  let _ =
    build_symbtl ();
  in
  let codes = [| 20; 30; 0; 10; 11; 4|] in
  let sym n =
    list_tail (top_symbtl ()) n |> get_car
  in
  let add_instruction op opnd =
    let top = tos () in
    let new_instr = make_rib op opnd (get_car top) in
    let new_rib = alloc_rib new_instr in
    field0_set top new_rib
  in
  let rec decode_loop () =
    let x = get_code () in
    loop 0 x x
  and loop op n x =
    let d = codes.(op) in
    if d+2 < n
    then loop (op+1) (n-(d+3)) x
    else begin
      if 90 < x
      then begin
        let opnd = pop () in
        add_instruction (Int 4) opnd;
        decode_loop ()
      end
      else begin
        if op = 0
        then push (Int op);
        let opnd =
          if n < d
          then
            if op < 3 then sym n else (Int n)
          else if n = d
          then Int (get_int 0)
          else sym (get_int (n-d-1))
        in if 4 < op
        then begin
          let ty = pop () in
          let code_proc = make_rib opnd (Int 0) ty in
          let code_proc_rib = alloc_rib code_proc in
          let proc = make_rib code_proc_rib nil_rib procedure_type in
          let proc_rib = alloc_rib proc in
          if is_rib (tos ())
          then begin
            add_instruction (Int 3) proc_rib;
            decode_loop ()
          end
        end
        else begin
          let op = if 0 < op then op-1 else 0 in
          add_instruction (Int op) opnd;
          decode_loop ()
          end
        end
      end
  in decode_loop ()


let get_cont () =
  let rec loop w =
    if is_rib (field2_word w)
    then w
    else loop (get_cdr w)
  in loop (tos ())

let get_var (opnd : word) =
  match opnd with
  Triplet _ -> field0_word opnd
  | Int i -> list_tail (tos ()) i |> field0_word
  | Nil -> failwith "can't get_var of Nil"

let set_var opnd v =
  match opnd with
  Triplet _ -> field0_set opnd v
  | Int i -> field0_set (list_tail (tos ()) i) v
  | Nil -> failwith "can't set_var of Nil"


let prim0 f = fun () -> f () |> push
let prim1 f = fun () -> pop () |> f |> push
let prim2 f = fun () ->
  let x = pop () in
  let y = pop () in
  f x y |> push

let prim3 f = fun () ->
  let x = pop () in
  let y = pop () in
  let z = pop () in
  let r = alloc_rib (f x y z) in
  push r

let to_bool x = if x then true_rib else false_rib

let getchar () =
  try input_char stdin |> int_of_char
  with End_of_file -> -1

let putchar (c : int) : int =
  if c = 0
  then Printf.printf "0"
  else char_of_int c |> print_char;
  flush stdout; c


let prim2_int (f : int -> int -> int) =
  let f_rib = fun y x ->
    match y, x with
    Int b, Int a -> Int (f a b)
    | _ -> failwith "not integers"
  in prim2 f_rib

let close x =
  make_rib (get_car x) (tos ()) procedure_type |>
  alloc_rib

let primitives = [|
  (* @@(primitives (gen body) *)
  prim3 (fun z y x -> make_rib x y z); (* @@(primitive (rib a b c))@@ *)
  prim1 (fun x -> x); (* @@(primitive (id x))@@ *)
  (fun () -> pop () |> ignore); (* @@(primitive (arg1 x y))@@ *)
  prim2 (fun y x -> y); (* @@(primitive (arg2 x y))@@ *)
  prim1 close; (* @@(primitive (close rib))@@ *)
  prim1 (fun x -> to_bool (is_rib x)); (* @@(primitive (rib? rib) (use bool2scm))@@ *)
  prim1 field0_word; (* @@(primitive (field0 rib))@@ *)
  prim1 field1_word; (* @@(primitive (field1 rib))@@ *)
  prim1 field2_word; (* @@(primitive (field2 rib))@@ *)
  prim2 (fun y x -> field0_set x y; y); (* @@(primitive (field0-set! rib))@@ *)
  prim2 (fun y x -> field1_set x y; y); (* @@(primitive (field1-set! rib))@@ *)
  prim2 (fun y x -> field2_set x y; y); (* @@(primitive (field2-set! rib))@@ *)
  prim2 (fun y x -> to_bool (is_eqv x y)); (* @@(primitive (eqv? x y) (use bool2scm))@@ *)
  (*  @@(primitive (< x y) @@ *)
prim2 (fun y x -> match y, x with
    Int b, Int a -> to_bool (a < b)
    | _ -> failwith "not integers");
    (*  )@@ *)
  prim2_int ( + ); (* @@(primitive (+ x y))@@ *)
  prim2_int ( - ); (* @@(primitive (- x y))@@ *)
  prim2_int ( * ); (* @@(primitive ( * x y))@@ *)
  prim2_int ( / ); (* @@(primitive (quotient x y))@@ *)

  prim0 (fun () -> Int (getchar ())); (* @@(primitive (getchar))@@ *)
  (* @@(primitive (putchar x) @@*) 
  prim1 (function Int c -> Int (putchar c)
                  | _ -> failwith "can't putchar_prim");
  (* )@@ *)
  |]

let step = ref 0

let rec run () =
  step := !step + 1;
  (*print_int !step;
  print_string " ";*)
  let (instr, opnd, next) = get_rib (Triplet !pc) in
  match instr with
  Int 0 ->
    print_debug "jump/call";
    (*print_stack (tos ());*)
    let proc = get_var opnd in
    let code = get_car proc in
    begin match code with
    Int i -> (* calling primitive *)
      "calling primitive " ^ (string_of_int i) |>
      print_debug;
      primitives.(i) ();
      if is_rib next
      then pc := int_of_triplet next
      else begin
        (* not a tail call *)
        let cont = get_cont () in
        field1_set (tos ()) (field0_word cont);
        pc := int_of_triplet (field2_word cont)
      end;
      run ()
    | Triplet i -> (* calling a lambda *)
      print_debug "calling lambda";
      let c2 = make_rib (Int 0) proc pair_type in
      let c2_rib = alloc_rib c2 in
      let nargs = int_of_Int (get_car code) in
      let rec loop n s =
        if n = 0
        then s
        else begin
          let new_s = make_rib (pop ()) s pair_type in
          loop (n-1) (alloc_rib new_s)
        end
      in let s = loop nargs c2_rib in
      if is_rib next
      then begin
        field0_set c2_rib (tos ());
        field2_set c2_rib next
      end else begin
        let k = get_cont () in
        field0_set c2_rib (field0_word k);
        field2_set c2_rib (field2_word k)
      end;
      stack := int_of_triplet s;
      pc := int_of_triplet (field2_word code);
      run ()
    | Nil -> failwith "can't call Nil"
    end
  | Int 1 -> (* set *)
    print_debug "set";
    set_var opnd (pop ());
    pc := int_of_triplet next;
    run ()
  | Int 2 -> (* get *)
    print_debug "get";
    let v = get_var opnd in
    push v;
    pc := int_of_triplet next;
    run ()
  | Int 3 -> (* const *)
    print_debug "const";
    push opnd;
    pc := int_of_triplet next;
    run ()
  | Int 4 -> (* if *)
    print_debug "if";
    let cond = pop () in
    if is_false cond
    then pc := int_of_triplet next
    else pc := int_of_triplet opnd;
    run ()
  | Int 5 -> (* halt *)
    print_debug "HALT!!"
  | _ -> failwith "not implemented yet"

let set_global v =
  field0_set (get_car (top_symbtl ())) v;
  symtbl := int_of_triplet (get_cdr (top_symbtl ()))

let _ =
  ram.(0) <- _nil;
  ram.(2) <- _true;
  ram.(3) <- _false;
  decode ();
  (* print_debug "decode over"; *)
  pc := !heap-2;
  let main = make_rib (Int 0) (top_symbtl ()) (Int 1) in
  let main_rib = alloc_rib main in
  set_global main_rib;
  set_global false_rib;
  set_global true_rib;
  set_global nil_rib;
  let halt = make_rib (Int 5) (Int 0) (Int 0) in
  ram.(!stack-1) <- halt;
  ram.(!stack-2) <- (Int 0, Int 0, Triplet (!stack-1));
  stack := !stack-2;
  run ()
