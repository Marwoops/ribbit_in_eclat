let input = "R\'rdadac,>,=>,qssa,oludom,htgnel-rotcev,?=<rahc,?qe,rahc-etirw,?regetni,?orez,etacnurt,xam,?=gnirts,!llif-rotcev,!tes-gnirts,gnirtsbus,regetni>-rahc,htgnel-gnirts,gniliec,tel,fer-rotcev,?=>gnirts,raaaac,?=>rahc,rddaac,dna,?=rahc,!tes,=,raddac,?<rahc,rotaremun,mcl,rotcev-ekam,enifed,!llif-gnirts,rahc>-regetni,?>rahc,qmem,rdaaac,adbmal,?naeloob,raaddc,?=<gnirts,?evitisop,gnirts-ekam,radaac,rotanimoned,!rdc-tes,raaadc,raadac,rddadc,ro,rorre,fi,nim,roolf,?evitagen,etouq,!tes-rotcev,cc/llac,ypoc-gnirts,dnuor,radddc,nigeb,radadc,=<,dnoc,rdaddc,rdaadc,rddddc,dneppa-gnirts,?ddo,tixe,?<gnirts,pam,vmem,?>gnirts,?erudecorp,tsil>-rotcev,tpxe,gnirts>-rebmun,esrever,?rotcev,!rac-tes,fer-gnirts,redniamer,cossa,rebmun>-gnirts,lave,rebmem,vssa,?neve,hcae-rof,dcg,lobmys>-gnirts,gnirts>-lobmys,raac,radc,raadc,raaac,rdddac,lper,?gnirts,rdadc,rdaac,fer-tsil,radac,raddc,rdddc,?tcejbo-foe,enilwen,rotcev>-tsil,dneppa,+,sba,?lobmys,?llun,yalpsid,etirw,htgnel,daer,rahc-keep,?lauqe,rddac,tneitouq,,gnirts>-tsil,tsil>-gnirts,ton,,,rddc,,,*,,rdac,,,,rac,?riap,rahc-daer,<,-,rdc,snoc,,?vqe,,,,,;9)!S,9Fl@YN@YF_@YGiU7@YG^{])9)@YN@YFZ6^8N~YO^YD@YT8vCvR3y]67#YU.^z!U.8THi&:HiU6ai&kkz!U6:kw\'k!TJ\'_*YTJaB_G^~F^{!T9\'^8T9YKlbB`^\'`~?_G_~F_|!TA8TG`^YT9ka_BaG`1YTAdBbAai$G`^~F_|!U/#`kn8:^~i$#`kn8:^~i$#`kn8:^~i$#`kn8:^~YT5Q^~?w)I^~?kJ^~YT5^z!U\'#YU/a_l{!TG#a_k#k_k~?iU6_{!?1b1:VfBdbw)k~FBaG`^|!T<1V:h-w7k1Vf~?iU6fdAaaa^}(!TF*i&^z!TI*YTF`^{!TB*YTIb`^|!T7*YTBca_wS+|!1#b`n8T<fAi&AbwU4awU4`8TAAea_`~YI_B`1ci$1cYT7APdxLABKcxOGKa1cABKbxO~?GKbwU5~FBa_~?xL^1ci$1cN^1cNYTBYT7APgwS-wU4wU4YTFYTI`wU4wSN~FPbKa~FBa_~?wS-^1ci%1cN^1cNYT7i$APdwSH^~FPbKa~FBa_~?wSH^8T<fPdK`G_`GK`~?wSN^8?cBa_~?xO^#YTGewT?#d~YHbYTHi&:ViU6PeYTJAAfi$i$akYE_nK`~?wS9^1:HgZ*ecHfYAdboKa_~?wS+^1YU\'dYT9lbKbYAa_~N?wS?_8T<fAi&AbwU4awU4`8TAAea_`~YI_B`1ci$1cYT7APdxLABKcxOGKa1cABKbxO~?GKbwU5~FBa_~?xL^1ci$1cN^1cNYTBYT7APgwS-wU4wU4YTFYTI`wU4wSN~FPbKa~FBa_~?wS-^1ci%1cN^1cNYT7i$APdwSH^~FPbKa~FBa_~?wSH^8T<fPdK`G_`GK`~?wSN^8?cBa_~?xO^#YTGewT?#d~YHbYTHi&:ViU6PeYTJAAfi$i$akYE_nK`~?wS9^1:HgZ*ecHfYAdboKa_~?wS+^1YU\'dYT9lbKbYAa_~N^~^?wSF^#cKan~?wS\'^G_~F_#bYT9k``m~YI_|!T85_@L^{!N5uy!T,i5!;\'i$8;aB_@L^8;aB_@L^@LvS#~N?vS#_8;aB_@L^8;aB_@L^@LvS#~N^~^?vE^8;aB_@LvS;@LvS#~?t^8;aB_@LvS9@LvS#~?v0^8;aB_@LvS5@LvS#~?u^8;aB_@L^~S`G^~F^{!TL\'i$\'i$8TLB^@YFG^~F^@LvC~F^z!G8GZ>^8T8vS7vF~ZA^8FZ@^@LvF~Z<^8;i$T^~Z(^8GZ/^~YI^5vL@YTLB^@YFG^@LvK~F^8T8vLvK~YH^8T8vS;vF~?i%^8T8vS-vF~S^z!F8G^5vE@Ri%T^@LvE~Z(^z!TN8TN8T>~?u^\'^~Dk^Ey!T>8T>@E\'^8TN~?vR0^~D_vC\'iU8~YO^YCy!T68T6A`^8T6Aa^8T6Aat~?vS;^8T6Aav0~?vS9^8T6Aau~?vS5^E~?vS#^9=_~?vE^\'i&~YO^Ez!T=*YT=^@E\'i&~NNDvD`*YT=^@E\'i&~NN^~^?vL_*YT=^@E\'i&~N^~^?vK^YCy!TM*YTM^YD\'i&@E~?vL^YT>y!8\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~DvR<^~D_vR588CCvR%_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~i$\'_88CCvRL_M`v3@E~i$\'_88CCvRL_M`v3@E~DvS.^~D_vS\'88CCvR,_M`v3@E~DvR<^~D_vR588CCvR%_M`v3@E~DvR/^~D_vR$YCz!D90`\'^~^^Z7^UAYT=^@E8>YT6i&@E~?vE^*Ai&YDwS\'@E~?vJ^8MYD,Okk88k@E~?vP^YC@E~N?vRM_8MYD,Okk88k@E~?vP^YC@E~N^~^?vS?^\'i%@E~?vS;^\'i$@E~?vS-^YC@E~?vF^8TM@E~?vK^\'^~Dk^YT>y!C\'^!U1^Ey!U&\'^!U1iU3\'^~?iU8^!U1^z!.8U&^8U&YU+~?iU3^\'^~?iU8^iU1y!U1iU3!O(iU8^z!S%7%YT?\'_@YU0Qc^@YTDJc^IIYT?i$zIIYT?i$z]2\'i$92B`^@X$G_~F_{]D\'i&*ZDBa_X$G_~F_{!TH#l`^{]AYT:l!T&8TDYT;aI_^{!S@8MYT;k^z!S&8TOb`J^|!SM9%`J^{!T/i2]@i3!M#oYE_^z]<YT:o!S>8TDYT;aI_^{!S$8>YLi&T^z]H8>YLT`T^{!TP8>a8TPAfZ:bb`a_Cl`~Da_}\'!T$8TPi&b`^|!U*\'k\'iU8~F_\'l8U*BbB`\'l~D`^\'iU8~D__G`G^~F_~F^{!TK8U*T`T^{!SL8<ZE`^{!S68<ZB`^{]B-YTKa_k{]E-kYTK`^{!T\'(kYTK`^{!S48>YT;vC^z!T%8TOb`J^|]:9%`J^{!SPi2!=i3!>#nYE_^z](YT:n!S=i\'!T#i\'!SJiT2!T.jM!S<iT3!SCi-!SGi(!U#\'_\'i$\'i$8U#CCvR%`MbuB_~DvR/^~D_vR$G^~F^{!U)8U#k^\'i$~YH^z]7\'i$,_k~^YU)^8U)B^~?vPG^\'i$~YH^T^z!TC\'^8TC_`~DakAb^YKCMu``vR%Wu^{]>8>YTCi&^8>AYTCi&C`kvP~Dk^z]?\'^6__~ZG`Z?Wm`M_^\'l~?k_{!S#i\'!T)i\'!SOi\'!S)i\'!S2\'lz!SBi\'!SA6_WZ1``_YJ`YJ^\'k~?k_{!T@8T@_Z9__\'_~?k^{]18T@`^8T@__~D__YJ`YJ^{!T08Kb^\'^~?DkbDk`\'k~?k^CM`a_W`^{]9,MWb``^{!J\'^,_k~Dk^z!S*\'_\'^~D`^{!T(\'^\'_~D`^{]G8<Z3^z]3(MWm`m^z!S(-k^z!S5-_kz!T*(k^z!T28<D`^{]M8<D__{!T3-__{!SEi(!T+8<YT5^z@YU,ki#!U2Ii#!U$\'^!U2AiU2^YU-^8U$Ia_\'^~YB`I^J_~F_{]08U$iU2^z]/i2!U-#m_i$z!IYT:m!U(\'`8U(Aca`Cl^~D_k|!T;8U(i&`^{]8\'i$98Ba_\'^~YBG__G_~F_{!T1j4]4\'i$94Ba_\'^~?G__G_~F_{]5\'i$95B`^\'_~YBG`^~F_{!S;jC]C\'i$9CB`^\'_~?G`^~F_{!TE\'^8TECl`B^~D`k{!TO9;aYTE`^|]%0YTE`^{!U%\'_8U%AaG_B^~F^{]=8U%i&^z!L\'_*YLaB_G^~F^{!E\'k8KYEB_l~F^z!H(i&^z]I8PI^z]P8PJ^z]K9#I^z!S79#J^z!S.9\'I^z]N9\'J^z]J9,I^z!S09,J^z!SD8AJ^z!T49$I^z!S/9$J^z!SI9&I^z!S39&J^z!S:9+I^z!SK9+J^z!P89I^z]#89J^z]\'9-I^z],9-J^z]$4J^z]&9.I^z]+9.J^z]-2J^z].3J^z]*8AI^z!A4I^z!92I^z!43I^z!S1iU,];iTD!+i2!0i3!*#k`^{!/YT:k!B\'i$\'i$\'i$\'i$8BJaJ_~YBIaI_~YBQaQ_~YT5`\'i$~?pQ_~YT5_\'^~^?`^{!T-i(!S88<_\'^~^?i%^z!<(i$^z!T:8T?\'i$(bQ^~YT5^zz!U7:nl:ki&vC!U3Cmk!U8Clk!\':lkl!):lkm!7:lkn!T?:lko!T5:lkp!3:lkq!2:lkr!::lks!TD:lkt!U,:lku!U0:lkv.!(:lkv/!-:lkv0!K:lkv1!,:lkv2!6:lkv3!@:lkv4!U+:lkv5!5:lkv6]F:lkv7y"
let debug = ref false

let print_debug s = if !debug then print_endline s

type word =
  Triplet of int
  | Int of int

type rib = word * word * word

let pair_type = Int 0
let procedure_type = Int 1
let symbol_type = Int 2
let string_type = Int 3
let vector_type = Int 4
let singleton_type = Int 5

let _nil = (Int 0, Int 0, singleton_type)
let _false = (Int 0, Int 0, singleton_type)
let _true = (Int 0, Int 0, singleton_type)

let size_ram = 40000
let fh_start = 4
let fh_end = size_ram / 2
let sh_start = fh_end
let sh_end = size_ram
let limit = ref fh_end
let brk = ref fh_start

let ram = Array.make size_ram _nil
let stack = ref (-1)
let heap = ref (-1)
let symtbl = ref (-1)
let pc = ref (-1)
let pos = ref 0

let rec show_rib prof (car, cdr, ty) =
  print_string "(";
  show_word prof car;
  print_string ", ";
  show_word prof cdr;
  print_string ", ";
  show_word prof ty;
  print_string ")"

and show_word prof = function
  Triplet i ->
    if prof = 0
    then print_string "X"
    else show_rib (prof - 1) ram.(i)
  | Int i -> print_int i

let rec show_address prof = function
  Triplet i ->
    if prof = 0 then print_string "X"
    else begin
    print_int i;
    print_string " -> (";
    let (car, cdr, ty) = ram.(i) in
    show_address (prof-1) car;
    print_string ", ";
    show_address (prof-1) cdr;
    print_string ", ";
    show_address (prof-1) ty;
    print_string ")";
    end
  | Int _ -> print_string "T"
  
(* init constants *)
let nil_rib = Triplet 0
let true_rib = Triplet 1
let false_rib = Triplet 2

let int_of_triplet (w : word) : int =
  match w with
  Triplet i -> i
  | Int _ -> failwith "can't int_of_triplet"

let int_of_Int (w : word) : int =
  match w with
  Int i -> i
  | Triplet _ -> failwith "can't int_of_Int"

let get_rib (w : word) =
  match w with
  Triplet i -> ram.(i)
  | Int _ -> failwith "can't get_rib"

let is_rib (w : word) : bool =
  match w with
  Triplet i -> i >= 0 && i < size_ram
  | Int _ -> false

let is_eqv (w1 : word) (w2 : word) : bool =
  match w1, w2 with
  Int i, Int j -> i = j
  | Triplet i, Triplet j -> (get_rib w1) = (get_rib w2)
  | _ -> false

let is_false (w : word) = w = false_rib

let make_rib x y z = (x, y, z)

let field0_rib (x, y, z) = x
let field1_rib (x, y, z) = y
let field2_rib (x, y, z) = z

let field0_word (w : word) = get_rib w |> field0_rib
let field1_word (w : word) = get_rib w |> field1_rib
let field2_word (w : word) = get_rib w |> field2_rib

let field0_set (w : word) (v : word) =
  match w with
  Triplet i ->
    ram.(i) <- (v, field1_word w, field2_word w)
  | Int _ -> failwith "can't field0_set"

let field1_set (w : word) (v : word) =
  match w with
  Triplet i ->
    ram.(i) <- (field0_word w, v, field2_word w)
  | Int _ -> failwith "can't field1_set"

let field2_set (w : word) (v : word) =
  match w with
  Triplet i ->
    ram.(i) <- (field0_word w, field1_word w, v)
  | Int _ -> failwith "can't field2_set"

let instance_of ty =
  fun (w  : word) -> is_rib w && field2_word w = ty

let is_pair (w : word) = instance_of pair_type w
let cons car cdr = make_rib car cdr pair_type
let get_car (w : word) = field0_word w
let get_cdr (w : word) = field1_word w

let move (w : word) next s e ns ne =
  (* s : start, e : end, ns : new start, ne : new end*)
  match w with
  Int _ -> (w, next)
  | Triplet i ->
    (* si w pointe dans origine *)
    if i >= s && i < e
    then begin
      match get_car w with
      (* si p.f0 pointe dans destination *)
      Triplet i when i >= ns && i < ne ->
        (Triplet i, next)
      | _ ->
        let f0 = field0_word w in
        let f1 = field1_word w in
        let f2 = field2_word w in
        ram.(next) <- (f0, f1, f2);
        let dest = Triplet next in
        field0_set w dest;
        (dest, next+1)
    end
    else (w, next)

let same_half i j =
  (i >= fh_start && i < fh_end && j >= fh_start && j < fh_end)
      ||
  (i >= sh_start && i < sh_end && j >= sh_start && j < sh_end)

let collect () =
  let (s, e, ns, ne) =
    if same_half !brk fh_start
    then (fh_start, fh_end, sh_start, sh_end)
    else(sh_start, sh_end, fh_start, fh_end)
  in
  limit := ne;
  let next = ns in
  let (new_stack, next) = move (Triplet !stack) next s e ns ne in
  let (new_symtbl, next) = move (Triplet !symtbl) next s e ns ne in
  let (new_pc, next) = move (Triplet !pc) next s e ns e in
  stack := int_of_triplet new_stack;
  symtbl := int_of_triplet new_symtbl;
  pc := int_of_triplet new_pc;
  let rec loop scan next =
    if next >= ne then failwith "memory is full";
    if scan < next
    then begin
      let (f0, f1, f2) = ram.(scan) in
      let (new_f0, next) = move f0 next s e ns ne in
      let (new_f1, next) = move f1 next s e ns ne in
      let (new_f2, next) = move f2 next s e ns ne in
      ram.(scan) <- (new_f0, new_f1, new_f2);
      loop (scan+1) next
    end
    else scan
  in brk := loop ns next; if !limit - !brk < 50 then failwith "not enough memory"


let not_enough_space () = !limit - !brk < 50

let get_next_i () =
  if !brk = !limit-1
  then (collect (); !brk)
  else begin
    brk := !brk + 1;
    !brk
  end

let pop () : word =
  let (car, cdr, _) = ram.(!stack) in
  stack := int_of_triplet cdr;
  car

let push (w : word) : unit =
  let i = get_next_i () in
  let new_tos = cons w (Triplet !stack) in
  stack := i;
  ram.(!stack) <- new_tos

let alloc_rib (r : rib) : word =
  let i = get_next_i () in
  heap := i;
  ram.(!heap) <- r;
  Triplet !heap

let tos () = Triplet !stack

let rec list_tail (w : word) (i : int) : word =
  if 0 < i
  then list_tail (get_cdr w) (i-1)
  else w

let rec pair_length (w : word) =
  if is_pair w
  then 1 + pair_length (get_cdr w)
  else 0

let get_byte () =
  let c = String.get input (!pos) in
  pos := !pos + 1;
  int_of_char c

let eb = 46

let get_code () =
  let x = (get_byte ()) - 35 in
  if x < 0 then 57 else x

let rec get_int n =
  let x = get_code () in
  let y = n * eb in
  if x < eb
  then y + x
  else get_int (y + (x - eb))


(* symbol table *)
let top_symtbl () =
    Triplet !symtbl

(* length from w till Nil *)
let rec length (w : word) : int =
  if is_pair w
  then 1 + (length (get_cdr w))
  else 0

let string_of_list (w : word) : rib =
  make_rib w (Int (length w)) string_type

let end_of_string (w : word) : rib =
  make_rib false_rib w symbol_type

let alloc_sym (sym : rib) =
  let i = get_next_i () in
  symtbl := i;
  ram.(!symtbl) <- sym;
  Triplet !symtbl

let add_symbol (chars : word) =
  let top = top_symtbl () in
  let str_rib = string_of_list chars |> alloc_sym in
  let end_rib = end_of_string str_rib |> alloc_sym in
  let sym = cons end_rib top in
  alloc_sym sym

let build_symtbl () =
  let rec loop1 n =
    if 0 < n
    then begin
      let _ = add_symbol nil_rib in
      loop1 (n-1)
    end
    else loop2 ()
  and loop2 () =
    loop3 nil_rib
  and loop3 chars =
    let x = get_byte () in
    if x = 44
    then let _ = add_symbol chars in loop2 ()
    else if x = 59
    then let _ = add_symbol chars in ()
    else begin
      let c = cons (Int x) chars in
      let c_rib = alloc_rib c in
      loop3 c_rib
    end
  in loop1 (get_int 0)

let decode () =
  let _ =
    build_symtbl ();
  in
  let codes = [| 20; 30; 0; 10; 11; 4|] in
  let sym n =
    list_tail (top_symtbl ()) n |> get_car
  in
  let add_instruction op opnd =
    let top = tos () in
    let new_instr = make_rib op opnd (get_car top) in
    let new_rib = alloc_rib new_instr in
    field0_set top new_rib
  in
  let rec decode_loop () =
    let x = get_code () in
    loop 0 x x
  and loop op n x =
    let d = codes.(op) in
    if d+2 < n
    then loop (op+1) (n-(d+3)) x
    else begin
      if 90 < x
      then begin
        let opnd = pop () in
        add_instruction (Int 4) opnd;
        decode_loop ()
      end
      else begin
        if op = 0
        then push (Int op);
        let opnd =
          if n < d
          then
            if op < 3 then sym n else (Int n)
          else if n = d
          then Int (get_int 0)
          else sym (get_int (n-d-1))
        in if 4 < op
        then begin
          let ty = pop () in
          let code_proc = make_rib opnd (Int 0) ty in
          let code_proc_rib = alloc_rib code_proc in
          let proc = make_rib code_proc_rib nil_rib procedure_type in
          let proc_rib = alloc_rib proc in
          if is_rib (tos ())
          then begin
            add_instruction (Int 3) proc_rib;
            decode_loop ()
          end
        end
        else begin
          let op = if 0 < op then op-1 else 0 in
          add_instruction (Int op) opnd;
          decode_loop ()
          end
        end
      end
  in decode_loop ()


let get_cont () =
  let rec loop w =
    if is_rib (field2_word w)
    then w
    else loop (get_cdr w)
  in loop (tos ())

let get_var (opnd : word) =
  match opnd with
  Triplet _ -> field0_word opnd
  | Int i -> list_tail (tos ()) i |> field0_word

let set_var opnd v =
  match opnd with
  Triplet _ -> field0_set opnd v
  | Int i -> field0_set (list_tail (tos ()) i) v


let prim0 f = fun () -> f () |> push
let prim1 f = fun () -> pop () |> f |> push
let prim2 f = fun () ->
  let x = pop () in
  let y = pop () in
  f x y |> push

let prim3 f = fun () ->
  let x = pop () in
  let y = pop () in
  let z = pop () in
  let r = alloc_rib (f x y z) in
  push r

let to_bool x = if x then true_rib else false_rib

let getchar () =
  try input_char stdin |> int_of_char
  with End_of_file -> -1

let putchar (c : int) : int =
  if c = 0
  then Printf.printf "0"
  else char_of_int c |> print_char;
  flush stdout; c

let prim2_int (f : int -> int -> int) =
  let f_rib = fun y x ->
    match y, x with
    Int b, Int a -> Int (f a b)
    | _ -> failwith "not integers"
  in prim2 f_rib

let close x =
  make_rib (get_car x) (tos ()) procedure_type |>
  alloc_rib

let primitives = [|
  (* @@(primitives (gen body) *)
  prim3 (fun z y x -> make_rib x y z); (* @@(primitive (rib a b c))@@ *)
  prim1 (fun x -> x); (* @@(primitive (id x))@@ *)
  (fun () -> pop () |> ignore); (* @@(primitive (arg1 x y))@@ *)
  prim2 (fun y x -> y); (* @@(primitive (arg2 x y))@@ *)
  prim1 close; (* @@(primitive (close rib))@@ *)
  prim1 (fun x -> to_bool (is_rib x)); (* @@(primitive (rib? rib) (use bool2scm))@@ *)
  prim1 field0_word; (* @@(primitive (field0 rib))@@ *)
  prim1 field1_word; (* @@(primitive (field1 rib))@@ *)
  prim1 field2_word; (* @@(primitive (field2 rib))@@ *)
  prim2 (fun y x -> field0_set x y; y); (* @@(primitive (field0-set! rib))@@ *)
  prim2 (fun y x -> field1_set x y; y); (* @@(primitive (field1-set! rib))@@ *)
  prim2 (fun y x -> field2_set x y; y); (* @@(primitive (field2-set! rib))@@ *)
  prim2 (fun y x -> to_bool (is_eqv x y)); (* @@(primitive (eqv? x y) (use bool2scm))@@ *)
  (*  @@(primitive (< x y) @@ *)
prim2 (fun y x -> match y, x with
    Int b, Int a -> to_bool (a < b)
    | _ -> failwith "not integers");
    (*  )@@ *)
  prim2_int ( + ); (* @@(primitive (+ x y))@@ *)
  prim2_int ( - ); (* @@(primitive (- x y))@@ *)
  prim2_int ( * ); (* @@(primitive ( * x y))@@ *)
  prim2_int ( / ); (* @@(primitive (quotient x y))@@ *)

  prim0 (fun () -> Int (getchar ())); (* @@(primitive (getchar))@@ *)
  (* @@(primitive (putchar x) @@*) 
  prim1 (function Int c -> Int (putchar c)
                  | _ -> failwith "can't putchar_prim");
  (* )@@ *)
  |]

let next_pc () =
  pc := int_of_triplet (field2_word (Triplet !pc))

let rec run () =
  let (instr, opnd, next) = get_rib (Triplet !pc) in
  match instr with
  Int 0 ->
    print_debug "jump/call";
    if not_enough_space () then collect ();
    let (_, opnd, next) = get_rib (Triplet !pc) in
    let proc = get_var opnd in
    let code = get_car proc in
    begin match code with
    Int i -> (* calling primitive *)
      "calling primitive " ^ (string_of_int i) |>
      print_debug;
      primitives.(i) ();
      if is_rib next
      then next_pc ()
      else begin
        (* not a tail call *)
        let cont = get_cont () in
        field1_set (tos ()) (field0_word cont);
        pc := int_of_triplet (field2_word cont)
      end;
      run ()
    | Triplet i -> (* calling a lambda *)
      print_debug "calling lambda";
      let c2 = make_rib (Int 0) proc pair_type in
      let c2_rib = alloc_rib c2 in
      let nargs = int_of_Int (get_car code) in
      let rec loop n s =
        if n = 0
        then s
        else begin
          let new_s = make_rib (pop ()) s pair_type in
          loop (n-1) (alloc_rib new_s)
        end
      in let s = loop nargs c2_rib in
      if is_rib next
      then begin
        field0_set c2_rib (tos ());
        field2_set c2_rib next
      end else begin
        let k = get_cont () in
        field0_set c2_rib (field0_word k);
        field2_set c2_rib (field2_word k)
      end;
      stack := int_of_triplet s;
      pc := int_of_triplet (field2_word code);
      run ()
    end
  | Int 1 -> (* set *)
    print_debug "set";
    set_var opnd (pop ());
    next_pc ();
    run ()
  | Int 2 -> (* get *)
    print_debug "get";
    let v = get_var opnd in
    push v;
    next_pc ();
    run ()
  | Int 3 -> (* const *)
    print_debug "const";
    push opnd;
    next_pc ();
    run ()
  | Int 4 -> (* if *)
    print_debug "if";
    let cond = pop () in
    if is_false cond
    then next_pc ()
    else pc := int_of_triplet opnd;
    run ()
  | Int 5 -> (* halt *)
    print_debug "HALT!!"
  | _ -> failwith "not implemented yet"

let set_global v =
  field0_set (get_car (top_symtbl ())) v;
  symtbl := int_of_triplet (get_cdr (top_symtbl ()))

let _ =
  decode ();
  let start_rib = (field2_word (field0_word (Triplet !heap))) in
  pc := int_of_triplet start_rib;
  let main = make_rib (Int 0) (top_symtbl ()) (Int 1) in
  let main_rib = alloc_rib main in
  set_global main_rib;
  set_global false_rib;
  set_global true_rib;
  set_global nil_rib;
  let halt = make_rib (Int 5) (Int 0) (Int 0) in
  let i = get_next_i () in
  let j = get_next_i () in
  ram.(i) <- halt;
  ram.(j) <- make_rib (Int 0) (Int 0) (Triplet i);
  stack := j;
  run ()
